use sqlx::Row;
use user_context::domain::valueobjects::UserId;

use crate::domain::valueobjects::{MessageContent, MessageTopic, RoomId, RoomToUserMessageId};

#[derive(Debug, Clone)]
pub struct RoomToUserRawMessage {
  id: RoomToUserMessageId,
  room_id: RoomId,
  user_id: UserId,
  topic: MessageTopic,
  content: MessageContent,
}

impl<'r> sqlx::FromRow<'r, sqlx::postgres::PgRow> for RoomToUserRawMessage {
  fn from_row(row: &'r sqlx::postgres::PgRow) -> Result<Self, sqlx::Error> {
    Ok(RoomToUserRawMessage {
      id: row.try_get::<uuid::Uuid, _>("id")?.into(),
      room_id: row.try_get("room_id")?,
      user_id: row.try_get("user_id")?,
      topic: row.try_get::<String, _>("topic")?.into(),
      content: row.try_get::<String, _>("content")?.into(),
    })
  }
}

impl RoomToUserRawMessage {
  /// Create a new RoomToUserRawMessage without an ID (ID will be generated by the database)
  pub fn without_id(room_id: RoomId, user_id: UserId, topic: MessageTopic, content: MessageContent) -> Self {
    Self {
      id: RoomToUserMessageId::from(uuid::Uuid::new_v4()), // Placeholder ID, will be replaced by database
      room_id,
      user_id,
      topic,
      content,
    }
  }

  /// Create a RoomToUserRawMessage with a specific ID (for reconstruction from database)
  pub fn with_id(
    id: RoomToUserMessageId, room_id: RoomId, user_id: UserId, topic: MessageTopic, content: MessageContent,
  ) -> Self {
    Self {
      id,
      room_id,
      user_id,
      topic,
      content,
    }
  }

  pub fn id(&self) -> RoomToUserMessageId {
    self.id
  }

  pub fn room_id(&self) -> RoomId {
    self.room_id
  }

  pub fn user_id(&self) -> UserId {
    self.user_id
  }

  pub fn topic(&self) -> &MessageTopic {
    &self.topic
  }

  pub fn content(&self) -> &MessageContent {
    &self.content
  }
}
